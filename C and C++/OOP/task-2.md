# Task 2: Проектування класів та їх методів
## Goal
Засвоїти поняття конструктора, деструктора та функцій-членів  класів

## Контент
- [Theoretical background](#Theoretical-background)
  * [Конструктори](#Конструктори)
  * [Типи конструкторів](#Типи-конструкторів)
  * [Деструктори](#Деструктори)

- [Tasks](#Tasks)

## Theoretical background
Одне з основних завдань об’єктно-орієнтованого програмування полягає у тому, щоб об’єкти описаного раз і назавжди класу працювали «правильно» — тобто так, як це визначає модель. Кожний об’єкт перед тим як почати роботу, потрібно створити, тобто перевести в якийсь початковий стан. Отже, треба якимось чином описати можливі механізми створення об’єктів даного класу.

### Конструктори

Для цього в мові C++ існують ``конструктори`` - це особливі методи класу, які й повинні перевести об’єкт у той самий початковий стан. Конструктор описується <ins>як метод</ins>, ім’я якого <ins>збігається</ins> з іменем класу, а тип поверненого значення - опущений (``void``). 

Приклад:
```cpp
class Point
{
  public:
    Point(int x0, int y0);
  private:
    int x, y;
};
Point::Point(int x0, int y0)
{
  x=x0;
  y=y0;
}
```
Тепер для створення об’єкта класу ``Point`` потрібно після імені змінної вказати параметри, як для виклику функції:
```cpp
Point A(1, 1), B(2, 0);
```

### Типи конструкторів
Існують деякі типи конструкторів, які, крім безпосереднього використання, автоматично викликаються у деяких особливих ситуаціях.

---
``1. Конструктор за замовчуванням`` - конструктор, що викликається без параметрів:

```cpp
Point();
Point(int a = 5);
```

Його використовують для створення масиву об’єктів, оскільки не зрозуміло, які конструктори і з якими параметрами треба викликати для кожного елемента масиву. 

Наприклад:

```cpp
Point A[10];            // static allocation
Point* B=new Point[10]; // dynamic allocation
```

```Конструктор за замовчуванням викликається також тоді, якщо не вказано параметри для ініціалізації об’єкта, як у цьому випадку:```
```cpp
Point p;
```
---

``2. Конструктор з параметрами`` - конструктор, що викликається тоді, коли потрібно створити об’єкт, ініціалізувавши його поля деякими значеннями.

```cpp
Point(2, 5);
Rectangle(2.0, 1.0, 50, 20);
Student("Sam", "Jackson");
```
---

``3. Конструктор копіювання`` - конструктор, що викликається тоді, коли потрібно створити <ins>копію</ins> об’єкта. 

Аргументом цього конструктора має бути ***посилання*** на об’єкт цього самого класу:
```cpp
Point(const Point &p);
```
Важливим випадком, коли викликається конструктор копіювання, є передавання об’єкта у функцію як параметра за значенням. Тоді створюється новий об’єкт і для нього автоматично викликається конструктор копіювання.

```Створення конструкторів копіювання потрібне у випадку, якщо об’єкт потребує якихось спеціальних операцій при копіюванні, оскільки під час стандартного копіювання вміст одного об’єкта просто побайтно переноситься в інший.```

Приклад:
```cpp
class String
{
public:
  String();                // конструктор за замовчуванням
  String(const String& s); // конструктор копіювання
  String(const char* s);   // конструктор з параметром
  
  ~String();               // деструктор
private:
  char* array;             // масив символів
  int size;                // розмір масиву
};
```

Приклад виклику конструкторів:
```cpp
int main()
{ String a, b;  // конструктор за замовчуванням
  String c(a);  // констр.копіювання, аргумент передається у ф. за знач.
  print(a);     
  
  String d(“One”);   // конструктор з параметром
  //  ...
}
```
---


### Деструктори

Конструктори ініціалізують об’єкт, тобто вони створюють середовище, у якому "працюють" функції-члени. Іноді створення такого середовища зумовлює "захоплення" якихось ресурсів: пам’яті, файлу, процесорного часу, які повинні бути "звільнені" після їх використання. 

Тобто класам потрібна функція, яка б <ins>знищувала</ins> об’єкт аналогічно тому, як його створює конструктор. Такі функції називають ```деструкторами```.

Приклад:
```cpp
class Name
 {
     const char* s;
     // ...
 };
        
class Table 
 {
    Name* p;
    size_t sz;
    
    public:   
        Table(size_t s=15) {p=new Name[sz=s];} // конструктор
        ~Table() {delete[] p;}                 // деструктор
// ...
 };
```

Як бачите, ```практичне використання деструктора - при роботі з динамічними даними: при виділенні пам'яті на них, треба обов'язково в кінці її звільнити.```


## Tasks:

Додати функціонал до класу, що робили минулий раз (``task-1.md``):

``a`` Реалізацію кострукторів усіх трьох типів;

``b`` Реалізацію деструктора (спробувати попрацювати з динамічною памяттю);

Тобто, все це повинно бути у вашому класі!
